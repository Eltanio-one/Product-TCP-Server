### Product-TCP-Server
## Overview
The code in this repository is representative of my efforts to further my understanding and abilities surrounding concurrent programming. The main objective of all branches of this repository are to create a TCP socket server that enables the client to pass a product code to the server, which will then query a product dictionary created within the python script for the list price of that product. The client handler will check for a disconnect message from the client, and will handle errors generated if a product code that has not yet been registered is passed by the client. The V1 branch contains my efforts of creating the TCP socket server using the socket and threading python libraries, whilst V2 (the current master branch) has translated this to enable asynchronous requesting using Python's asyncio library.
# thread_server.py
Contains the code that enables requests to the TCP socket server using multi-threading. The product dictionary is built using two lists, PRODUCT_LIST and PRICE_LIST, that were pulled from an example order sheet. The main function is used to set up the socket, binding to the relevant host and port global keys (imported from globals.py to save repeating in thread_client.py). The start_socket() is passed the socket object that was created in the main function, and waits for a connection to be initiated by a client for 30 seconds before timing out due to inactivity. When a client connects, the handle_client function is activated as the connection handler, and this will read the data (product code) the client has provided via the command line, and check if this was either the stated DISCONN_MSG to terminate the connection, and if not whether the passed product code is in the product dictionary. If so, then the relevant list price is sent back to the client, or an error is sent. Each time a connection is made, a new thread is created using the threading library.
# thread_client.py
Contains the code that connects to the TCP server and queries its product dictionary with a command-line passed produce code. The code handles incorrect numbers of command-line arguments, before setting up a client socket and connecting the same host and port and executing the send_data function. Following TCP protocol, The send_data function encodes the product code, and then encodes the length of the clients message. This is then padded out the be 64 bytes long, before being sent just before the product code is sent. The client socket then listens for a response from the server, decodes the response, and then handles whether to disconnect, or print an error or list price that was passed back from the server.
# async_server.py
Contains code that performs the same function as the thread_server.py file, but instead of threading uses the asyncio library to execute asynchronous concurrent programming. The main function establishes the socket server and waits until a client connects, which it then passes to the handler function handle_client. The handle_client function then reads the clients request and performs the same checks as above to ensure the product code is valid before passing the necessary response back to the client.
# async_client.py
Contains the code that performs the same function as thread_client.py but using asyncio.
# globals.py
Contains global variables DISONN_MSC for client disconnecting, NOTFOUND_MSG for if a product code that is not stored in the product dictionary is requested, HEADER which is 64, and HOST and PORT for the address (localhost) and chosen port.
# setup.py
Contains product code and price lists to create the product dictionary.